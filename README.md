An example ESP32 application which uses `esp-idf` with a Rust crate supplying
`app_main`. An appropriate rustc is selected from the
rbtying/esp-crossbuild-env, which should minimize the amount of effort
necessary to comiple the code.

This project is built against `esp-idf` v4.0, so make sure you have the
appropriate toolchain installed.

The default `idf.py` tooling should work for building and flashing the ESP32:

```
idf.py build
idf.py flash -p $PORT
idf.py monitor -p $PORT
```

The Rust build has been integrated into the `esp-idf` CMake, but for
development it'll be less annoying to try and compile the crate directly:

```
cd main
docker run --rm --mount type=bind,source="$(pwd)",target=/project rbtying/esp-crossbuild-env cargo +xtensa xbuild --target xtensa-esp32-none-elf --release
```

The `esp-idf` bindings can be regenerated using `bindgen.sh` from the root of
the `main` directory after running `idf.py build`. The `bindings.h` file in
`esp-idf-sys` should be updated to match whichever components you want to
include in the bindgen; the appropriate header paths should be generated by the
`main` component's `CMakeLists.txt`.
